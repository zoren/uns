[func assert [c message] [if c 0 [abort message]]]

[func inc [x] [add x 1]]

[func dec [x] [sub x 1]]

[func is-whitespace [c]
    [switch c
      [0x09 0x0a 0x0d 0x20] ; '\t' '\n' '\r' ' '
      1
      0]]

[func is-between [lower c upper] [and [le lower c] [le c upper]]]

[func is-digit [c] [is-between 0x30 c 0x39]]

[func is-ident-char [c]
  [or
    [is-between 0x61 c 0x7a] ; a-z
    [or
      [is-between 0x2d c 0x2e] ; -.
      [is-digit c]]]]

[func get-token [start end]
  [assert [lt start end] 'empty token']
  [let [c [load8u start]]
    [switch c

      [0x09 0x0a 0x0d 0x20] ; '\t' '\n' '\r' ' '
      [loop [j [inc start]]
        [if [if [lt j end] [is-whitespace [load8u j]] 0]
          [recur [inc j]]
          [list 1 start j j]]]

      0x27 ; '\''
      [loop [j [inc start]]
        [if [if [lt j end] [neq [load8u j] 0x27] 0]
          [recur [inc j]]
          [list 2 [inc start] [dec j] [inc j]]]]

;      [0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39] ; '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
;      [loop [j [inc start]]
;        [if [if [lt j end] [is-digit [load8u j]] 0]
;          [recur [inc j]]
;          [list 3 start j j]]]

      0x3b ; ';'
      [loop [j [inc start]]
        [if [if [lt j end] [neq [load8u j] 0x0a] 0]
          [recur [inc j]]
          [list 4 start j j]]]

      [0x5b 0x5d] ; '[' ']'
      [list 5 start [inc start] [inc start]]

      [if [is-ident-char c]
        [loop [j [inc start]]
          [if [if [lt j end] [is-ident-char [load8u j]] 0]
            [recur [inc j]]
            [list 6 start j j]]]

        [abort 'unexpected character' c]]]]]

[func is-align4 [x] [eq [and x 3] 0]]

;; init memory top
[store32 0 4]

[func alloc [size]
  [assert [ge size 0] 'alloc negative size']
  [assert [le size 65536] 'alloc too large, more than 64k']
  [assert [is-align4 size] 'alloc not aligned']
  [let
    [current-top [load32 0]
     - [assert current-top 'memory not initialized - no top']
     - [assert [is-align4 current-top] 'current top not aligned']
     mem-bytes [mul 65536 [memory-pages]]
     - [assert [le current-top mem-bytes] 'out of memory - top outside memory before alloc']
     new-top [add current-top size]]
    [assert [le new-top mem-bytes] 'out of memory - top outside memory after alloc']
    [store32 0 new-top]
    current-top]]

; dynamic object system
; an object has a tag and a payload (size depends on tag)
; tags
; maybe make them odd so a tag can also be a pointer
; 1 - i32
; 15 - character
; 17 - string i32 length + utf8 bytes (u8)
; 19 - array i32 length + i32 elements
; custom tags are pointers to descriptors

[func alloc-i32 [value]
  [let [p [alloc 8]]
    [store32 p 1]
    [store32 [add p 4] value]
    p]]

[func alloc-char [value]
  [let [p [alloc 8]]
    [store32 p 15]
    [store32 [add p 4] value]
    p]]

[func alloc-string-from-bytes [pointer size]
  [let [s [alloc [add size 8]]]
    [store32 s 17]
    [store32 [add s 4] size]
    [memory-copy [add s 8] pointer size]
    s]]

[print-object [alloc-i32 42]]

[print-object [alloc-string-from-bytes 0 0]]

[func get-tokens [start end]
  [loop [i start]
    [if [lt i end]
      [let [token [get-token i end]]
        [print token]
        [recur [nth token 2]]]
      0]]]

[func parse [s]
  [let
    [start [nth s 0]
     len [nth s 1]]
    [get-tokens start [add start len]]]]

;  [parse [active 'hej [du] ; ']]

;  [parse [active '[add 2 4]']]

[func print-ascii []
  [loop [i 32]
    [print-object [alloc-char i]]
    [if [lt i 126]
      [recur [inc i]]
      []]]]

[print-ascii]
