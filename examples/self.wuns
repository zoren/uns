[macro comment [.. -] []]

[func inc [x] [add x [quote 1]]]

[func dec [x] [sub x [quote 1]]]

[func not [c] [eqz c]]

[func is-odd [x] [bit-and x [quote 1]]]

[func is-even [x] [not [is-odd x]]]

[func is-negative [x] [lt x [quote 0]]]

[func is-whitespace [c]
  [bit-or [eq c [quote 32]] [eq c [quote 10]]]]

[func is-square-bracket [c]
  [bit-or [eq c [quote 91]] [eq c [quote 93]]]]

[func is-between-inclusive [lower c upper]
  [bit-and [le lower c] [le c upper]]]

[func is-digit [c] [is-between-inclusive [quote 48] c [quote 57]]]

[func is-ident-char [c]
  [bit-or
    [is-between-inclusive [quote 97] c [quote 122]]
    [bit-or
      [is-digit c]
      [is-between-inclusive [quote 45] c [quote 46]]
      ]]]

[macro when-not [cond .. forms]
  [list
    [quote if] cond
    []
    [concat [list [quote do]] forms]]]

[macro if-not [cond then else]
  [list
    [quote if] cond
    else
    then
    ]]

[func quote-all [l]
  [let [s [size l]
        qq [quote quote]]
    [loop [i [quote 0]
           res [list]]
      [if [lt i s]
        [cont [inc i] [concat res [list qq [nth l i]]]]
        res]]]]

[macro assert [cond .. lmsg]
  [concat
    [list [quote when-not] cond]
    []
    [list [quote abort] [quote ass-fail]]]]

[macro ifs [.. clauses]
  [let [s [size clauses]]
    [assert [is-odd s] ifs requires an odd number of forms]
    [loop [res [nth clauses [dec s]]
           i [dec s]]
      [if i
        [cont
          [list [quote if]
            [nth clauses [sub i [quote 2]]]
            [nth clauses [dec i]]
            res]
          [sub i [quote 2]]]
        res]]]]

[macro and [.. clauses]
  [let [s [size clauses]]
    [ifs
      [eq s [quote 0]]]
      [quote 1]

      [eq s [quote 1]]
      [nth clauses 0]

    [loop [i [sub s [quote 2]]
           r [nth clauses [dec s]]]
      [if [eq i [dec [quote 0]]]
        r
        [cont
          [dec i]
          [list [quote if]
            [nth clauses i]
            r
            [quote 0]
        ]]
      ]
    
    ]
  ]
]

[func get-token [code-points start end]
  [loop [i start]
    [if [ge i end]
      [list [quote eof] i i]

      [let [tok-start i
            c [nth code-points i]]
        [ifs
          [is-whitespace c]
          [cont [inc i]]

          [is-square-bracket c]
          [list [word [list c]] i [inc i]]

          [is-ident-char c]
          [loop [j [inc i]]
            [if [if [lt j end] [is-ident-char [nth code-points j]] [quote 0]]
              [cont [inc j]]
              [list [quote ident] tok-start j]]]

          [abort unexpected-character]]]]]]

[func sum-num-words [codes]
  [let [s [size codes]]
    [loop [i [quote 0]
          sum [quote 0]]
      [if [lt i s]
        [cont [inc i] [add sum [nth codes i]]]
        sum]]]]

[macro do [.. forms]
  [concat [list [quote let] []] forms]]

[macro when [cond .. forms]
  [list
    [quote if] cond
    [concat [list [quote do]] forms]
    []]]

[macro test-assert [c]
  [when-not c
    [abort c]]]

[test-assert
  [eq
    [sum-num-words [quote [1 20 300]]]
    [quote 321]]]

[func lex [code-points]
  [let [s [size code-points]]
    [loop [i [quote 0]
           tokens [quote []]]
      [if [ge i s]
        tokens
        [let [tup [get-token code-points i s]
              c [nth tup [quote 0]]
              start [nth tup [quote 1]]
              end [nth tup [quote 2]]]
            [if [eq c [quote eof]]
              tokens
              [cont end [concat tokens
                [list [if [eq c [quote ident]]
                        [word [slice code-points start end]]
                        c]]]]]]]]]]

[log [lex [quote [97 98]]]]

[func first [l] [nth l [quote 0]]]

[func second [l] [nth l [quote 1]]]

[func parse1 [tokens i]
  [when [ge i [size tokens]]
    [abort [quote unexpected-end-of-input]]]
  [let [token [nth tokens i]]
    [if-not [eq token [word [quote [91]]]]

      [list token [inc i]]
      [loop [ls []
             j [inc i]]
        [ifs
          [ge j [size tokens]]
          [list ls j]

          [eq [nth tokens j] [word [quote [93]]]]
          [list ls [inc j]]

          [let [res [parse1 tokens j]
                f [first res]
                k [second res]]
            [cont [concat ls [list f]] k]]]]

      ]]]

[log
  [parse1
   [lex [quote [91 97 98 32 48 93 32]]]
   [quote 0]
   ]]

[func parse-chars [code-points]
  [first [parse1 [lex code-points] [quote 0]]]]

[func join [l sep]
  [let [s [size l]]
    [loop [i [quote 0]
           res [quote []]]
      [if [lt i s]
        [cont [inc i] [concat res [list [nth l i] sep]]]
        [concat-words res]]]]]

[func print [f]
  [if [is-word f]
    f
    [let [s [size f]]
      [concat-words
        [word [quote 91]]
        [if [eq s [quote 0]]
          [word []]
          [loop [i [quote 0]
                 res []]
            [if [lt i [dec s]]
              [cont [inc i] [concat res [print [nth f i]] [word [quote 32]]]]
              [concat-words [concat res [print [nth f [dec s]]]]]]]]
        [word [quote 93]]]]
        
      ]
      
      ]

[log [quote print-testing]]
[log [print []]]
[log [print [quote [f 3 [4 df]]]]]
